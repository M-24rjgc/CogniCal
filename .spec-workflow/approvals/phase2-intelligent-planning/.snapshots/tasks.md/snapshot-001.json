{
  "id": "snapshot_1760084363487_6ja2qdpdi",
  "approvalId": "approval_1760084363436_jxkrcy8wg",
  "approvalTitle": "Phase 2 Intelligent Planning — Tasks",
  "version": 1,
  "timestamp": "2025-10-10T08:19:23.487Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document\r\n\r\n- [ ] 1. Extend planning database schema and migrations\r\n  - File: src-tauri/src/db/schema.sql; src-tauri/src/db/migrations.rs (new migration entry)\r\n  - Add `planning_sessions`, `planning_options`, `planning_time_blocks`, `schedule_preferences` tables with indices and foreign keys\r\n  - Wire the new migration into the runner and provide data seeding defaults for preferences snapshot\r\n  - Purpose: Persist planning sessions, options, time blocks, and personalization data locally\r\n  - _Leverage: existing task tables and migration helpers in src-tauri/src/db/migrations.rs_\r\n  - _Requirements: 1, 2, 4_\r\n  - _Prompt: Role: Rust backend engineer specializing in SQLite migrations | Task: Add the planning-related tables and migration wiring following requirements 1, 2, and 4, mirroring existing migration helpers and ensuring referential integrity | Restrictions: Keep migrations idempotent, follow timestamped migration naming, ensure foreign key cascades align with task deletions | Success: Schema compiles, migration applies cleanly, and new tables are ready for planning services_\r\n\r\n- [ ] 2. Create planning models and repository layer\r\n  - File: src-tauri/src/models/planning.rs (new); src-tauri/src/db/repositories/planning_repository.rs (new); update mod.rs exports\r\n  - Define Rust structs mirroring the new tables and implement CRUD helpers for sessions, options, time blocks, and preferences snapshotting\r\n  - Purpose: Provide typed accessors for planning persistence used by services\r\n  - _Leverage: src-tauri/src/models/task.rs, src-tauri/src/db/repositories/task_repository.rs_\r\n  - _Requirements: 1, 2, 4_\r\n  - _Prompt: Role: Rust data layer developer | Task: Introduce planning models and repository functions aligned with requirements 1, 2, and 4, reusing patterns from task models/repositories | Restrictions: Use From/Into conversions for serde JSON columns, respect transaction boundaries, expose only required methods for services | Success: Repository supports session creation, option/time block reads & writes, and preference storage with tests ready to consume_\r\n\r\n- [ ] 3. Implement schedule optimizer service and utilities\r\n  - File: src-tauri/src/services/schedule_optimizer.rs (new); src-tauri/src/services/mod.rs (register); src-tauri/src/services/schedule_utils.rs (new helper)\r\n  - Generate ranked plan options, detect conflicts, and score blocks using provided constraints and preferences\r\n  - Purpose: Supply deterministic scheduling candidates and conflict detection for PlanningService\r\n  - _Leverage: src-tauri/src/services/task_service.rs, src-tauri/src/utils/semantic.rs_\r\n  - _Requirements: 1, 2, 3_\r\n  - _Prompt: Role: Rust algorithms engineer with focus on scheduling | Task: Build the ScheduleOptimizer module per requirements 1, 2, and 3, factoring scoring helpers into schedule_utils.rs and following existing service registration patterns | Restrictions: Keep interfaces pure for unit testing, expose deterministic outputs when seeded, surface conflict metadata for UI consumers | Success: Optimizer returns multiple ranked options with conflict data and integrates cleanly into the service layer_\r\n\r\n- [ ] 4. Implement behavior learning service with preference feedback\r\n  - File: src-tauri/src/services/behavior_learning.rs (new); update src-tauri/src/services/mod.rs\r\n  - Snapshot user preferences before planning, ingest feedback after task completion, and adjust weights based on execution history\r\n  - Purpose: Adapt scheduling to user performance and expose preferences for UI editing\r\n  - _Leverage: src-tauri/src/services/task_service.rs, src-tauri/src/services/cache_service.rs_\r\n  - _Requirements: 3, 4_\r\n  - _Prompt: Role: Rust ML infrastructure engineer | Task: Implement BehaviorLearningService satisfying requirements 3 and 4, reusing task metrics and cache utilities to manage preference data | Restrictions: Keep preference updates transactional, support offline caching, and expose clear error types for command layer | Success: Preferences snapshot/ingest APIs operate correctly and feed into planning sessions_\r\n\r\n- [ ] 5. Orchestrate planning workflow in PlanningService\r\n  - File: src-tauri/src/services/planning_service.rs (new); update src-tauri/src/services/mod.rs\r\n  - Coordinate repositories, optimizer, behavior learning, and AI explanations to produce planning sessions, apply options, and resolve conflicts\r\n  - Purpose: Centralize planning business logic with transactional guarantees\r\n  - _Leverage: src-tauri/src/services/ai_service.rs, src-tauri/src/services/task_service.rs, ScheduleOptimizer, BehaviorLearningService_\r\n  - _Requirements: 1, 2, 3, 4_\r\n  - _Prompt: Role: Rust service orchestrator | Task: Implement PlanningService covering requirements 1-4, coordinating optimizer, AI summaries, repositories, and conflict resolution | Restrictions: Maintain transactional integrity, log decision paths for debugging, emit structured errors for the command layer | Success: Service exposes generate, apply, resolve APIs used by Tauri commands and passes integration tests_\r\n\r\n- [ ] 6. Expose planning commands in Tauri layer\r\n  - File: src-tauri/src/commands/planning.rs (new); src-tauri/src/commands/mod.rs; src-tauri/src/main.rs registration\r\n  - Add `planning_generate`, `planning_apply`, `planning_resolve_conflict`, and `planning_preferences_*` commands invoking PlanningService and BehaviorLearningService\r\n  - Purpose: Provide frontend access to planning capabilities via invoke API\r\n  - _Leverage: src-tauri/src/commands/task.rs, src-tauri/src/utils/logger.rs_\r\n  - _Requirements: 1, 2, 3, 4_\r\n  - _Prompt: Role: Tauri command engineer | Task: Wire planning commands per requirements 1-4, matching invoke patterns and structured responses from existing command modules | Restrictions: Use CommandResult wrapper, map domain errors to AppError codes, emit planning events through AppHandle | Success: Commands build, expose correct payloads, and forward events to the frontend_\r\n\r\n- [ ] 7. Define planning TypeScript types and tauriApi bindings\r\n  - File: src/types/planning.ts (new); src/services/tauriApi.ts (extend); src/utils/taskLabels.ts (ensure labels map); vite-env declarations if needed\r\n  - Model planning session, option, conflict, preference DTOs and add invoke helpers for new commands\r\n  - Purpose: Enable strongly-typed planning data flow on frontend\r\n  - _Leverage: src/types/task.ts, src/services/tauriApi.ts existing patterns_\r\n  - _Requirements: 1, 2, 3, 4_\r\n  - _Prompt: Role: TypeScript platform engineer | Task: Create planning types and tauriApi helpers aligned with requirements 1-4, reusing existing DTO patterns and error mappers | Restrictions: Avoid breaking existing exports, ensure JSON parsing safety, keep enums string literal based | Success: New types compile, tauriApi exposes typed helpers, and lint/tests succeed_\r\n\r\n- [ ] 8. Build planning store and hooks for session management\r\n  - File: src/stores/planningStore.ts (new); src/hooks/usePlanning.ts (new); update providers/toast-provider if needed\r\n  - Manage generate/apply/resolve flows, loading states, event subscriptions, and preference CRUD\r\n  - Purpose: Centralize planning state and provide reusable hooks to UI components\r\n  - _Leverage: src/stores/taskStore.ts, src/hooks/useTasks.ts, src/providers/toast-provider.tsx_\r\n  - _Requirements: 1, 2, 3, 4_\r\n  - _Prompt: Role: React state management specialist | Task: Implement planning store and hook covering requirements 1-4, mirroring taskStore patterns and handling command events | Restrictions: Keep Zustand slices serializable, surface optimistic updates carefully, reuse toast/error helpers | Success: Store exposes typed actions/selectors, integrates with tauri events, and unit tests pass_\r\n\r\n- [ ] 9. Implement planning UI components and integrate into task workflows\r\n  - File: src/components/tasks/TaskPlanningPanel.tsx (new or extend); src/components/tasks/PlanOptionCard.tsx (new); src/components/tasks/ConflictResolutionSheet.tsx (new); src/components/tasks/PersonalizationDialog.tsx (new); update TaskDetailsDrawer.tsx and TaskTable.tsx triggers\r\n  - Present plan generation trigger, option cards with CoT summaries, conflict sheet with resolution actions, and personalization dialog for preferences\r\n  - Purpose: Deliver end-to-end planning interaction to users within tasks experience\r\n  - _Leverage: src/components/tasks/TaskTable.tsx, src/components/tasks/TaskDetailsDrawer.tsx, src/components/ui/* primitives_\r\n  - _Requirements: 1, 2, 3, 4_\r\n  - _Prompt: Role: Senior React engineer focusing on UX flows | Task: Build planning UI per requirements 1-4, reusing existing design system components and ensuring accessibility | Restrictions: Maintain responsive layouts, lazy-load heavy panels, hook into planningStore without duplicating state | Success: Users can generate plans, inspect CoT, resolve conflicts, and adjust preferences directly in the UI_\r\n\r\n- [ ] 10. Sync calendar view with planning time blocks\r\n  - File: src/pages/Calendar.tsx; src/components/tasks/TaskTable.tsx (selection context); src/styles/globals.css (scoped styles if needed)\r\n  - Display newly applied time blocks, highlight conflicts, and keep calendar synchronized with planningStore events\r\n  - Purpose: Visualize scheduled time blocks and changes resulting from planning\r\n  - _Leverage: existing calendar data adapters in src/pages/Calendar.tsx_\r\n  - _Requirements: 2, 3_\r\n  - _Prompt: Role: Frontend engineer specializing in calendaring UIs | Task: Integrate planning time blocks into the calendar per requirements 2 and 3, reusing existing calendar utilities and maintaining performance | Restrictions: Avoid duplicate renders, respect timezone handling, ensure conflict badges align with design | Success: Calendar reflects applied plans, updates reactively, and highlights conflicts_\r\n\r\n- [ ] 11. Write Rust unit and integration tests for planning pipeline\r\n  - File: src-tauri/src/services/schedule_optimizer.rs (tests module); src-tauri/src/services/behavior_learning.rs (tests); tests/integration/planning_flow.rs (new)\r\n  - Cover optimizer scoring/conflict detection, behavior preference updates, and end-to-end generate/apply/resolve flow using in-memory SQLite\r\n  - Purpose: Guarantee backend planning logic correctness and regression safety\r\n  - _Leverage: existing test helpers in src-tauri/src/services/task_service.rs tests, rusqlite in-memory setup_\r\n  - _Requirements: 1, 2, 3, 4_\r\n  - _Prompt: Role: Rust test engineer | Task: Author unit and integration tests fulfilling requirements 1-4, using in-memory DB and mocked AI responses to verify planning workflows | Restrictions: Keep tests deterministic, isolate external API calls, assert transactional rollbacks on failure | Success: Tests pass, cover success/failure cases, and protect core planning logic_\r\n\r\n- [ ] 12. Add frontend unit tests for planning store and components\r\n  - File: src/__tests__/planningStore.test.ts (new); src/__tests__/TaskPlanningPanel.test.tsx (new); update vitest config if necessary\r\n  - Validate store reducers, command interactions, UI rendering of options/conflicts, and preference editing flows\r\n  - Purpose: Ensure frontend planning logic behaves as expected\r\n  - _Leverage: src/__tests__/taskStore.test.ts, src/__tests__/smoke.test.ts patterns_\r\n  - _Requirements: 1, 2, 3, 4_\r\n  - _Prompt: Role: React testing engineer | Task: Implement Vitest/RTL tests addressing requirements 1-4, mocking tauriApi calls and verifying user stories | Restrictions: Avoid brittle snapshot tests, emphasize behavior assertions, reuse shared test utilities | Success: Tests cover critical states, pass reliably, and document expected UX behavior_\r\n\r\n- [ ] 13. Extend Playwright E2E coverage for planning journey\r\n  - File: e2e/planning.e2e.ts (new); update playwright.config.ts if routes needed\r\n  - Automate user flow: select tasks → generate plans → review CoT → apply option → handle conflict → confirm calendar update\r\n  - Purpose: Validate planning feature end-to-end in desktop runtime\r\n  - _Leverage: e2e/smoke.e2e.ts setup, existing selectors in smoke.spec.ts_\r\n  - _Requirements: 1, 2, 3, 4_\r\n  - _Prompt: Role: QA automation engineer | Task: Create Playwright E2E test covering requirements 1-4, using stable selectors and waiting on tauri events | Restrictions: Keep test resilient to timing variance, capture screenshots on failure, reuse login/setup helpers | Success: E2E passes locally/CI and proves the planning journey works as expected_\r\n",
  "fileStats": {
    "size": 12512,
    "lines": 107,
    "lastModified": "2025-10-10T08:19:14.018Z"
  },
  "comments": []
}